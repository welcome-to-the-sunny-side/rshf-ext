/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/content/content.ts":
/*!********************************!*\
  !*** ./src/content/content.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/dom */ \"./src/utils/dom.ts\");\n\nconsole.log('[RSHF-EXT] Content script loaded!');\n// Hardcoded settings - don't try to load from storage\nconst HARDCODED_SETTINGS = {\n    group: 'abc',\n    showAlternativeRating: true,\n    noGroupRatingStyle: 'asterisk',\n    maxReplacementsPerPage: 2000,\n    cacheThresholdMinutes: 30\n};\n// Import rating utility functions (based on misc_info.md)\nconst getRatingColor = (rating) => {\n    if (rating < 0)\n        return '#808080'; // Default for users without ratings\n    if (rating < 1200)\n        return '#808080'; // Newbie (gray)\n    if (rating < 1400)\n        return '#008000'; // Pupil (green)\n    if (rating < 1600)\n        return '#03A89E'; // Specialist (cyan)\n    if (rating < 1900)\n        return '#0000ff'; // Expert (blue)\n    if (rating < 2100)\n        return '#a0a'; // Candidate Master (violet)\n    if (rating < 2300)\n        return '#FF8C00'; // Master (orange)\n    if (rating < 2400)\n        return '#FF8C00'; // International Master (orange)\n    if (rating < 2600)\n        return '#ff0000'; // Grandmaster (red)\n    if (rating < 3000)\n        return '#ff0000'; // International Grandmaster (red)\n    return '#ff0000'; // Legendary Grandmaster (red)\n};\nconst getRankName = (rating) => {\n    if (rating < 0)\n        return \"Not Rated\";\n    if (rating < 1200)\n        return \"Newbie\";\n    if (rating < 1400)\n        return \"Pupil\";\n    if (rating < 1600)\n        return \"Specialist\";\n    if (rating < 1900)\n        return \"Expert\";\n    if (rating < 2100)\n        return \"Candidate Master\";\n    if (rating < 2300)\n        return \"Master\";\n    if (rating < 2400)\n        return \"International Master\";\n    if (rating < 2600)\n        return \"Grandmaster\";\n    if (rating < 3000)\n        return \"International Grandmaster\";\n    return \"Legendary Grandmaster\";\n};\nlet isEnabled = true;\nlet observingDom = false;\n/**\n * Initialize the content script\n */\nfunction init() {\n    console.log('Codeforces Alternative Rating extension initialized');\n    // Use hardcoded settings\n    const settings = HARDCODED_SETTINGS;\n    // Add toggle button to the page\n    addToggleButton();\n    // Start MutationObserver to handle dynamically loaded content\n    startObservingDom();\n    // Process existing elements\n    processPage();\n    // No message listeners with hardcoded settings\n}\n/**\n * Process all rated users on the page\n */\nfunction processPage() {\n    // Return early if extension is disabled\n    if (!isEnabled)\n        return;\n    console.log('Processing page with settings:', HARDCODED_SETTINGS);\n    // Find all username elements\n    const usernameElements = _utils_dom__WEBPACK_IMPORTED_MODULE_0__.DomUtils.findUsernameElements();\n    console.log(`[RSHF-EXT] Found ${usernameElements.length} username elements`);\n    // Debug: Print a few of the found elements to see their structure\n    if (usernameElements.length > 0) {\n        console.log('[RSHF-EXT] Sample elements:', Array.from(usernameElements).slice(0, 3).map(el => ({\n            text: el.textContent,\n            classes: el.className,\n            html: el.outerHTML\n        })));\n    }\n    // Early return if no elements found\n    if (usernameElements.length === 0)\n        return;\n    // Extract usernames\n    const usernames = _utils_dom__WEBPACK_IMPORTED_MODULE_0__.DomUtils.extractUsernames(usernameElements);\n    console.log(`[RSHF-EXT] Found ${usernames.length} usernames:`, usernames.slice(0, 5), '...');\n    // Return early if settings indicate not to show alternative ratings\n    if (!HARDCODED_SETTINGS.showAlternativeRating) {\n        console.log('[RSHF-EXT] Alternative ratings disabled in settings');\n        // Reset all elements to original style\n        Array.from(usernameElements).forEach(el => {\n            _utils_dom__WEBPACK_IMPORTED_MODULE_0__.DomUtils.resetElementStyle(el);\n        });\n        return;\n    }\n    // Generate random ratings for usernames (mock data)\n    const ratingsMap = {};\n    usernames.forEach(username => {\n        // 80% chance of having a rating\n        const hasRating = Math.random() < 0.8;\n        ratingsMap[username] = hasRating ? Math.floor(Math.random() * 4000) : -1;\n    });\n    console.log('[RSHF-EXT] Generated mock ratings:', Object.entries(ratingsMap).slice(0, 5));\n    // Apply ratings to elements\n    Array.from(usernameElements).forEach((element, index) => {\n        const username = usernames[index];\n        if (!username)\n            return;\n        const rating = ratingsMap[username];\n        const ratingInfo = {\n            color: getRatingColor(rating),\n            name: getRankName(rating)\n        };\n        _utils_dom__WEBPACK_IMPORTED_MODULE_0__.DomUtils.applyRatingStyle(element, rating, ratingInfo, HARDCODED_SETTINGS);\n    });\n}\n/**\n * Add a toggle button to the page to enable/disable the extension\n */\nfunction addToggleButton() {\n    const button = document.createElement('button');\n    button.textContent = isEnabled ? 'Disable Alt Ratings' : 'Enable Alt Ratings';\n    button.style.cssText = `\n    position: fixed;\n    bottom: 20px;\n    right: 20px;\n    z-index: 9999;\n    padding: 8px 12px;\n    background: #4CAF50;\n    color: white;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 14px;\n    opacity: 0.8;\n  `;\n    button.addEventListener('click', toggleExtension);\n    document.body.appendChild(button);\n}\n/**\n * Toggle the extension on/off\n */\nfunction toggleExtension() {\n    isEnabled = !isEnabled;\n    // Update button text\n    const button = document.querySelector('button[style*=\"position: fixed\"]');\n    if (button) {\n        button.textContent = isEnabled ? 'Disable Alt Ratings' : 'Enable Alt Ratings';\n        button.style.background = isEnabled ? '#4CAF50' : '#F44336';\n    }\n    // Process or reset page\n    if (isEnabled) {\n        processPage();\n    }\n    else {\n        // Reset all elements to original style\n        const usernameElements = _utils_dom__WEBPACK_IMPORTED_MODULE_0__.DomUtils.findUsernameElements();\n        Array.from(usernameElements).forEach(el => {\n            _utils_dom__WEBPACK_IMPORTED_MODULE_0__.DomUtils.resetElementStyle(el);\n        });\n    }\n}\n/**\n * Start observing DOM changes to handle dynamically loaded content\n */\nfunction startObservingDom() {\n    if (observingDom)\n        return;\n    const observer = new MutationObserver((mutations) => {\n        let hasRatedUsers = false;\n        // Check if any of the mutations add elements with the rated-user class\n        for (const mutation of mutations) {\n            if (mutation.type === 'childList') {\n                for (const node of Array.from(mutation.addedNodes)) {\n                    if (node instanceof HTMLElement) {\n                        if (node.classList?.contains('rated-user') ||\n                            node.querySelector('.rated-user')) {\n                            hasRatedUsers = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (hasRatedUsers)\n                break;\n        }\n        // Process page if rated users were added\n        if (hasRatedUsers && isEnabled) {\n            processPage();\n        }\n    });\n    // Start observing\n    observer.observe(document.body, {\n        childList: true,\n        subtree: true\n    });\n    observingDom = true;\n}\n// Wait for document to be fully loaded\nif (document.readyState === 'loading') {\n    console.log('[RSHF-EXT] Document still loading, waiting for DOMContentLoaded...');\n    document.addEventListener('DOMContentLoaded', () => {\n        console.log('[RSHF-EXT] DOMContentLoaded fired, initializing...');\n        // Run our code after a short delay to make sure everything is fully rendered\n        setTimeout(() => {\n            try {\n                init();\n                console.log('[RSHF-EXT] Initialization complete');\n            }\n            catch (error) {\n                console.error('[RSHF-EXT] Initialization failed:', error);\n            }\n        }, 500);\n    });\n}\nelse {\n    console.log('[RSHF-EXT] Document already loaded, initializing...');\n    // Run our code after a short delay to make sure everything is fully rendered\n    setTimeout(() => {\n        try {\n            init();\n            console.log('[RSHF-EXT] Initialization complete');\n        }\n        catch (error) {\n            console.error('[RSHF-EXT] Initialization failed:', error);\n        }\n    }, 500);\n}\n\n\n//# sourceURL=webpack://rshf-ext/./src/content/content.ts?");

/***/ }),

/***/ "./src/shared/constants.ts":
/*!*********************************!*\
  !*** ./src/shared/constants.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API: () => (/* binding */ API),\n/* harmony export */   DEFAULT_SETTINGS: () => (/* binding */ DEFAULT_SETTINGS),\n/* harmony export */   DEFAULT_USER: () => (/* binding */ DEFAULT_USER),\n/* harmony export */   NO_GROUP_RATING_COLOR: () => (/* binding */ NO_GROUP_RATING_COLOR),\n/* harmony export */   SELECTORS: () => (/* binding */ SELECTORS),\n/* harmony export */   STORAGE_KEYS: () => (/* binding */ STORAGE_KEYS)\n/* harmony export */ });\n// Shared constants for the extension\n// Default settings\nconst DEFAULT_SETTINGS = {\n    group: '',\n    showAlternativeRating: true,\n    noGroupRatingStyle: 'opacity',\n    maxReplacementsPerPage: 2000,\n    cacheThresholdMinutes: 30\n};\n// Storage keys\nconst STORAGE_KEYS = {\n    SETTINGS: 'settings',\n    CACHE: 'cache',\n    USER: 'user'\n};\n// Default user (until login is implemented)\nconst DEFAULT_USER = 'TestUser';\n// Codeforces DOM selectors\nconst SELECTORS = {\n    RATED_USER: '.rated-user'\n};\n// Special color for users without group ratings\nconst NO_GROUP_RATING_COLOR = '#964B00'; // Brown\n// API endpoints (will be replaced with real endpoints later)\nconst API = {\n    BASE_URL: 'https://api.example.com', // Placeholder\n    GET_RATINGS: '/ratings'\n};\n\n\n//# sourceURL=webpack://rshf-ext/./src/shared/constants.ts?");

/***/ }),

/***/ "./src/utils/dom.ts":
/*!**************************!*\
  !*** ./src/utils/dom.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DomUtils: () => (/* binding */ DomUtils)\n/* harmony export */ });\n/* harmony import */ var _shared_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/constants */ \"./src/shared/constants.ts\");\n\n// Map rating ranges to Codeforces user class names\nconst RATING_TO_CLASS_MAP = [\n    { maxRating: 1199, className: 'user-gray' },\n    { maxRating: 1399, className: 'user-green' },\n    { maxRating: 1599, className: 'user-cyan' },\n    { maxRating: 1899, className: 'user-blue' },\n    { maxRating: 2099, className: 'user-violet' },\n    { maxRating: 2399, className: 'user-orange' },\n    { maxRating: 2999, className: 'user-red' },\n    { maxRating: Infinity, className: 'user-legendary' }\n];\n/**\n * Utilities for DOM manipulation\n */\nclass DomUtils {\n    /**\n     * Find all username elements on the page\n     * @returns NodeList of username elements\n     */\n    static findUsernameElements() {\n        console.log('[RSHF-EXT] Looking for elements with selector:', _shared_constants__WEBPACK_IMPORTED_MODULE_0__.SELECTORS.RATED_USER);\n        const elements = document.querySelectorAll(_shared_constants__WEBPACK_IMPORTED_MODULE_0__.SELECTORS.RATED_USER);\n        console.log(`[RSHF-EXT] Found ${elements.length} elements with class 'rated-user'`);\n        return elements;\n    }\n    /**\n     * Extract usernames from elements\n     * @param elements Elements to extract usernames from\n     * @returns Array of usernames\n     */\n    static extractUsernames(elements) {\n        return Array.from(elements).map(el => el.textContent?.trim() || '');\n    }\n    /**\n     * Get the appropriate Codeforces class name based on rating\n     * @param rating User's rating\n     * @returns CSS class name for the rating\n     */\n    static getRatingClassName(rating) {\n        // Find the corresponding class for the rating\n        for (const range of RATING_TO_CLASS_MAP) {\n            if (rating <= range.maxRating) {\n                return range.className;\n            }\n        }\n        // Default to legendary for any extremely high ratings\n        return 'user-legendary';\n    }\n    /**\n     * Apply rating color to an element\n     * @param element Element to apply color to\n     * @param rating User's rating\n     * @param settings Extension settings\n     */\n    static applyRatingStyle(element, rating, ratingInfo, settings) {\n        console.log(`[RSHF-EXT] Applying rating style for ${element.textContent}, rating: ${rating}`);\n        // Check if user has a rating in the selected group\n        const hasGroupRating = rating !== -1;\n        // Store original classes to preserve other functionality\n        const originalClasses = element.className.split(' ');\n        const preservedClasses = originalClasses.filter(cls => !cls.startsWith('user-') && cls !== 'rated-user');\n        // Apply the appropriate class/style based on settings\n        if (hasGroupRating) {\n            // User has a rating in the selected group - use proper Codeforces classes\n            const ratingClass = this.getRatingClassName(rating);\n            // Set the new class list with our rating class\n            element.className = ['rated-user', ratingClass, ...preservedClasses].join(' ');\n            // Remove any inline styles that might have been applied before\n            element.removeAttribute('style');\n            // Update the title to show our alternative rating\n            element.setAttribute('title', `Alternative Rating: ${rating} (${ratingInfo.name})`);\n            console.log(`[RSHF-EXT] Applied class: ${ratingClass} for rating: ${rating}`);\n        }\n        else {\n            // User does not have a rating in the selected group - apply custom styling\n            // Preserve the rated-user class for consistency\n            element.className = ['rated-user', ...preservedClasses].join(' ');\n            switch (settings.noGroupRatingStyle) {\n                case 'opacity':\n                    // Keep original color class but add opacity\n                    // First get the original color class if possible\n                    const originalColorClass = originalClasses.find(cls => cls.startsWith('user-'));\n                    if (originalColorClass) {\n                        element.classList.add(originalColorClass);\n                        element.style.opacity = '0.5';\n                    }\n                    else {\n                        // If no original color class, fallback to gray with opacity\n                        element.classList.add('user-gray');\n                        element.style.opacity = '0.5';\n                    }\n                    break;\n                case 'strikethrough':\n                    // Keep original color class but add strikethrough\n                    const strikethroughColorClass = originalClasses.find(cls => cls.startsWith('user-'));\n                    if (strikethroughColorClass) {\n                        element.classList.add(strikethroughColorClass);\n                    }\n                    else {\n                        // Fallback to gray with strikethrough\n                        element.classList.add('user-gray');\n                    }\n                    // Apply custom strikethrough with black line at 0.5 opacity\n                    // We can't directly set opacity only for the line through CSS alone\n                    // So we'll use a CSS technique with text-decoration-color and text-decoration-thickness\n                    const htmlElement = element;\n                    htmlElement.style.setProperty('text-decoration', 'line-through', 'important');\n                    htmlElement.style.setProperty('text-decoration-color', 'rgba(0, 0, 0, 0.2)', 'important'); // Black with 0.5 opacity\n                    htmlElement.style.setProperty('text-decoration-thickness', '1px', 'important'); // Thinner line for better appearance\n                    console.log('[RSHF-EXT] Applied custom strikethrough to', element.textContent);\n                    break;\n                case 'brown':\n                    // Remove any existing color classes and apply brown color\n                    element.style.color = '#964B00';\n                    break;\n                case 'asterisk':\n                    // Keep original color class and add black asterisk\n                    const asteriskColorClass = originalClasses.find(cls => cls.startsWith('user-'));\n                    if (asteriskColorClass) {\n                        element.classList.add(asteriskColorClass);\n                    }\n                    else {\n                        element.classList.add('user-gray');\n                    }\n                    // Add asterisk to name if not already present\n                    if (!element.textContent?.includes('*')) {\n                        const username = element.textContent || '';\n                        // Create a span for the asterisk\n                        const asterisk = document.createElement('span');\n                        asterisk.textContent = '*';\n                        asterisk.style.color = 'black'; // Make asterisk black\n                        asterisk.style.fontWeight = 'bold'; // Make it bold for visibility\n                        // Clear the element's text content and add the username\n                        element.textContent = username;\n                        // Append the asterisk span\n                        element.appendChild(asterisk);\n                        console.log('[RSHF-EXT] Added black asterisk to', username);\n                    }\n                    break;\n            }\n            element.setAttribute('title', 'No rating in selected group');\n        }\n    }\n    /**\n     * Reset element to original style\n     * @param element Element to reset\n     */\n    static resetElementStyle(element) {\n        // Store original classes - we only want to preserve the non-user class ones\n        const originalClasses = element.className.split(' ');\n        const preservedClasses = originalClasses.filter(cls => !cls.startsWith('user-'));\n        // Find the original color class if it exists in data attribute (we'll store it on modification)\n        const originalColorClass = element.getAttribute('data-original-color-class');\n        if (originalColorClass) {\n            preservedClasses.push(originalColorClass);\n            element.removeAttribute('data-original-color-class');\n        }\n        // Restore classes\n        element.className = preservedClasses.join(' ');\n        // Remove inline styles\n        element.removeAttribute('style');\n        element.removeAttribute('title');\n        // Remove asterisk if it was added\n        if (element.textContent?.endsWith('*')) {\n            element.textContent = element.textContent.slice(0, -1);\n        }\n        console.log(`[RSHF-EXT] Reset element style: ${element.textContent}`);\n    }\n}\n\n\n//# sourceURL=webpack://rshf-ext/./src/utils/dom.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/content/content.ts");
/******/ 	
/******/ })()
;